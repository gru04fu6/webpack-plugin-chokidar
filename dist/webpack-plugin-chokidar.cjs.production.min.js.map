{"version":3,"file":"webpack-plugin-chokidar.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["\nimport { watch } from 'chokidar';\nimport { WatchOptions, FSWatcher } from 'chokidar';\nimport { Stats } from 'fs';\n\ndeclare type eventName = 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir';\nexport interface Target {\n    compiler: any;\n    compilation: any;\n    watcher: FSWatcher;\n}\nexport interface ChokidarPluginFileEvent {\n    ready(target: Target): void;\n    add(target: Target, path: string, status?: Stats): void;\n    addDir(target: Target, path: string, status?: Stats): void;\n    change(target: Target, path: string, status?: Stats): void;\n    unlink(target: Target, path: string, status?: Stats): void;\n    unlinkDir(target: Target, path: string, status?: Stats): void;\n    raw(target: Target, eventName: string, path: string, details: any): void;\n    all(target: Target, eventName: eventName, path: string, status?: Stats): void;\n    error(target: Target, e: Error): void;\n}\nexport interface ChokidarEvent {\n    on?: Partial<ChokidarPluginFileEvent>;\n    close?: Promise<void>;\n    add?(paths: string | ReadonlyArray<string>): void;\n    unwatch?(paths: string | ReadonlyArray<string>): void;\n    getWatched?(): {\n        [directory: string]: string[];\n    };\n}\nexport interface ChokidarConfig {\n    file: string | ReadonlyArray<string>;\n    opt: WatchOptions;\n    actions: ChokidarEvent;\n}\nexport interface PluginOption {\n    chokidarConfigList: ChokidarConfig[];\n}\n\nclass ChokidarPlugin {\n    PluginName: string;\n    options: PluginOption;\n    listening: boolean;\n\n    constructor(options: PluginOption) {\n        this.PluginName = 'ChokidarPlugin';\n        this.options = options;\n        this.listening = false;\n    }\n\n    apply(compiler: any) {\n        compiler.hooks.watchRun.tapAsync(this.PluginName, (compilation: any, callback: any) => {\n            if (this.listening) callback();\n            const { chokidarConfigList = [] } = this.options;\n\n            for(const _ret of chokidarConfigList) {\n              const { file, opt, actions } = _ret;\n\n              if (!actions || !Object.keys(actions).length) continue;\n\n              const watcher = watch(file, opt);\n\n              Object.entries(actions).forEach(action => {\n                  const [listen, cbs] = action;\n\n                  if (listen === 'on') {\n                      Object.entries(cbs as ChokidarPluginFileEvent).forEach( _ref => {\n                          const [name, cb] = _ref;\n\n                          watcher[listen](name, (...args) => {\n                              cb({\n                                  compiler,\n                                  compilation,\n                                  watcher\n                              }, ...args);\n                          });\n                      });\n                  }\n\n              });\n            }\n\n            this.listening = true;\n            callback();\n        });\n    }\n}\n\nmodule.exports = ChokidarPlugin;\n"],"names":["module","exports","options","PluginName","listening","apply","compiler","hooks","watchRun","tapAsync","this","compilation","callback","_this","chokidarConfigList","_ret","file","opt","actions","Object","keys","length","watcher","watch","entries","forEach","action","listen","_ref","cb","args"],"mappings":"iJAyFAA,OAAOC,8BA5CSC,QACHC,WAAa,sBACbD,QAAUA,OACVE,WAAY,qBAGrBC,MAAA,SAAMC,cACFA,EAASC,MAAMC,SAASC,SAASC,KAAKP,YAAY,SAACQ,EAAkBC,GAC7DC,EAAKT,WAAWQ,gBACgBC,EAAKX,QAAjCY,oCAEEC,UACAC,EAAuBD,EAAvBC,KAAMC,EAAiBF,EAAjBE,IAAKC,EAAYH,EAAZG,YAEdA,IAAYC,OAAOC,KAAKF,GAASG,OAAQ,qBAExCC,EAAUC,QAAMP,EAAMC,GAE5BE,OAAOK,QAAQN,GAASO,SAAQ,SAAAC,OACrBC,EAAeD,KAEP,OAAXC,GACAR,OAAOK,QAHWE,MAG6BD,SAAS,SAAAG,OACvCC,EAAMD,KAEnBN,EAAQK,GAFWC,MAEG,sCAAIE,2BAAAA,kBACtBD,gBAAG,CACCvB,SAAAA,EACAK,YAAAA,EACAW,QAAAA,WACEQ,+sBArBK,yBA6B7BjB,EAAKT,WAAY,EACjBQ"}